---
title: "KD-GAT Experiment Dashboard"
format:
  dashboard:
    orientation: rows
    scrolling: true
    theme:
      - cosmo
      - custom.scss
    nav-buttons: [github]
---

```{ojs}
//| output: false

// --- Mosaic vgplot + DuckDB-WASM init ---
import { vg, loadParquetTable } from "./_ojs/mosaic-setup.js"

async function loadTable(name, attachment) {
  const url = await attachment.url();
  await loadParquetTable(name, url);
}

await loadTable("metrics", FileAttachment("data/metrics.parquet"));
await loadTable("runs", FileAttachment("data/runs.parquet"));
await loadTable("training_curves", FileAttachment("data/training_curves.parquet"));
await loadTable("recon_errors", FileAttachment("data/recon_errors.parquet"));
await loadTable("attention_weights", FileAttachment("data/attention_weights.parquet"));
await loadTable("dqn_policy", FileAttachment("data/dqn_policy.parquet"));
await loadTable("cka_similarity", FileAttachment("data/cka_similarity.parquet"));
await loadTable("embeddings", FileAttachment("data/embeddings.parquet"));

// --- Static JSON data ---
datasets_json = FileAttachment("data/datasets.json").json()
kd_transfer_json = FileAttachment("data/kd_transfer.json").json()
model_sizes_json = FileAttachment("data/model_sizes.json").json()
graph_samples_json = FileAttachment("data/graph_samples.json").json()

// --- Precompute shared summaries ---
summary_stats = {
  const runs_result = await vg.coordinator().query(
    vg.sql`SELECT COUNT(*) AS total_runs FROM runs`
  );
  const total_runs = Array.from(runs_result)[0].total_runs;

  const best_f1_result = await vg.coordinator().query(
    vg.sql`SELECT MAX(f1) AS best_f1, model FROM metrics GROUP BY model ORDER BY best_f1 DESC LIMIT 1`
  );
  const best_f1_row = Array.from(best_f1_result)[0];

  const kd_data = kd_transfer_json.data.filter(d => d.metric_name === "f1");
  let kd_gap = null;
  if (kd_data.length > 0) {
    const gaps = kd_data.map(d => d.teacher_value - d.student_value);
    kd_gap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
  }

  const dataset_result = await vg.coordinator().query(
    vg.sql`SELECT COUNT(DISTINCT dataset) AS n_datasets FROM runs`
  );
  const n_datasets = Array.from(dataset_result)[0].n_datasets;

  return {
    total_runs,
    best_f1: best_f1_row?.best_f1,
    best_model: best_f1_row?.model,
    kd_gap,
    n_datasets,
  };
}

// --- Leaderboard data from metrics parquet ---
leaderboard_data = {
  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        split_part(run_id, '/', 1) AS dataset,
        model,
        f1, accuracy, precision, recall, auc, mcc
      FROM metrics
      ORDER BY dataset, model
    `
  );
  return Array.from(result);
}
```

# Overview

## Row {height=15%}

```{ojs}
//| component: valuebox
//| title: "Total Runs"
//| icon: activity
//| color: primary
summary_stats.total_runs
```

```{ojs}
//| component: valuebox
//| title: "Best F1 Score"
//| icon: award
//| color: success
`${summary_stats.best_f1?.toFixed(4)} (${summary_stats.best_model})`
```

```{ojs}
//| component: valuebox
//| title: "Datasets"
//| icon: database
//| color: info
summary_stats.n_datasets
```

```{ojs}
//| component: valuebox
//| title: "Avg KD Gap (F1)"
//| icon: arrow-down-right
//| color: warning
summary_stats.kd_gap != null ? summary_stats.kd_gap.toFixed(4) : "N/A"
```

## Row {height=45%}

```{ojs}
//| title: "Leaderboard"

viewof selectedLeaderboardMetric = Inputs.select(
  ["f1", "accuracy", "precision", "recall", "auc", "mcc"],
  { label: "Metric", value: "f1" }
)

{
  const metric = selectedLeaderboardMetric;
  const data = leaderboard_data.map(d => ({
    dataset: d.dataset,
    model: d.model,
    value: d[metric],
  })).filter(d => d.value != null);

  return Inputs.table(data, {
    columns: ["dataset", "model", "value"],
    header: { dataset: "Dataset", model: "Model", value: metric.toUpperCase() },
    sort: "value",
    reverse: true,
    format: { value: d => d?.toFixed(4) },
    width: { dataset: 120, model: 80, value: 100 },
  });
}
```

```{ojs}
//| title: "Dataset Comparison"

viewof selectedDatasetMetric = Inputs.select(
  ["f1", "accuracy", "precision", "recall", "auc", "mcc"],
  { label: "Metric", value: "f1" }
)

{
  const metric = selectedDatasetMetric;
  const data = leaderboard_data.map(d => ({
    dataset: d.dataset,
    model: d.model,
    value: d[metric],
  })).filter(d => d.value != null);

  return Plot.plot({
    width: 600,
    height: 300,
    marginLeft: 80,
    x: { label: metric.toUpperCase(), domain: [0, 1.01] },
    y: { label: null },
    color: {
      legend: true,
      domain: ["gat", "vgae", "fusion"],
      range: ["#3fb950", "#58a6ff", "#bc8cff"],
    },
    marks: [
      Plot.barX(data, Plot.groupY(
        { x: "max" },
        { y: "dataset", x: "value", fill: "model", sort: { y: "-x" } }
      )),
      Plot.ruleX([0]),
    ],
  });
}
```

## Row {height=40%}

```{ojs}
//| title: "F1 Scores by Dataset and Model"
vg.plot(
  vg.dot(
    vg.from("metrics"),
    {
      x: vg.sql`split_part(run_id, '/', 1)`,
      y: "f1",
      fill: "model",
      r: 7,
      opacity: 0.8
    }
  ),
  vg.width(680),
  vg.height(260),
  vg.colorLegend(true),
  vg.colorDomain(["gat", "vgae", "fusion"]),
  vg.colorRange(["#3fb950", "#58a6ff", "#bc8cff"]),
  vg.xLabel("Dataset"),
  vg.xTickRotate(-30),
  vg.yLabel("F1 Score"),
  vg.yDomain([0.5, 1.01])
)
```

```{ojs}
//| title: "Model Parameter Counts"
{
  const data = model_sizes_json.data;
  return Plot.plot({
    width: 400,
    height: 260,
    marginLeft: 80,
    x: { label: "Parameters (millions)" },
    y: { label: null },
    color: { legend: true, domain: ["large", "small"], range: ["#58a6ff", "#79c0ff"] },
    marks: [
      Plot.barX(data, {
        y: d => `${d.model_type} (${d.scale})`,
        x: "param_count_M",
        fill: "scale",
        sort: { y: "-x" }
      }),
      Plot.text(data, {
        y: d => `${d.model_type} (${d.scale})`,
        x: "param_count_M",
        text: d => `${d.param_count_M}M`,
        dx: 5,
        textAnchor: "start",
        fontSize: 11
      }),
      Plot.ruleX([0])
    ]
  });
}
```

# Performance

## Row {height=50%}

```{ojs}
//| title: "Bubble Chart: F1 vs Accuracy (size = parameters)"
{
  const sizes = new Map(model_sizes_json.data.map(d => [d.model_type, d.param_count_M]));

  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        split_part(run_id, '/', 1) AS dataset,
        model,
        f1, accuracy, auc
      FROM metrics
      WHERE f1 IS NOT NULL AND accuracy IS NOT NULL
    `
  );
  const data = Array.from(result).map(d => ({
    ...d,
    param_count_M: sizes.get(d.model) || 0.1,
  }));

  return Plot.plot({
    width: 680,
    height: 400,
    color: {
      legend: true,
      domain: ["gat", "vgae", "fusion"],
      range: ["#3fb950", "#58a6ff", "#bc8cff"],
    },
    r: { range: [4, 30] },
    x: { label: "F1 Score", domain: [0.4, 1.01] },
    y: { label: "Accuracy", domain: [0.4, 1.01] },
    marks: [
      Plot.dot(data, {
        x: "f1",
        y: "accuracy",
        r: "param_count_M",
        fill: "model",
        fillOpacity: 0.6,
        stroke: "model",
        tip: true,
        title: d => `${d.dataset} / ${d.model}\nF1: ${d.f1.toFixed(4)}\nAcc: ${d.accuracy.toFixed(4)}\nParams: ${d.param_count_M}M`,
      }),
      Plot.line([[0.4, 0.4], [1, 1]], {
        stroke: "#8b949e",
        strokeDasharray: "4,4",
        strokeWidth: 1,
      }),
    ],
  });
}
```

```{ojs}
//| title: "Pareto Frontier: F1 vs Parameter Count"
{
  const sizes = new Map(model_sizes_json.data.map(d => [
    `${d.model_type}_${d.scale}`,
    d.param_count_M,
  ]));

  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        split_part(run_id, '/', 1) AS dataset,
        model,
        f1
      FROM metrics
      WHERE f1 IS NOT NULL
    `
  );
  const raw = Array.from(result);

  // Aggregate: best F1 per model (across datasets)
  const grouped = new Map();
  for (const d of raw) {
    for (const scale of ["large", "small"]) {
      const key = `${d.model}_${scale}`;
      const params = sizes.get(key);
      if (params == null) continue;
      const prev = grouped.get(key);
      if (!prev || d.f1 > prev.f1) {
        grouped.set(key, { model: d.model, scale, param_count_M: params, f1: d.f1, label: key });
      }
    }
  }
  const data = Array.from(grouped.values());

  // Compute Pareto front (minimize params, maximize F1)
  const sorted = [...data].sort((a, b) => a.param_count_M - b.param_count_M);
  const pareto = [];
  let bestF1 = -Infinity;
  for (let i = sorted.length - 1; i >= 0; i--) {
    if (sorted[i].f1 >= bestF1) {
      bestF1 = sorted[i].f1;
      pareto.unshift(sorted[i]);
    }
  }

  return Plot.plot({
    width: 680,
    height: 400,
    x: { label: "Parameters (millions)", type: "log" },
    y: { label: "Best F1 Score", domain: [0.5, 1.01] },
    color: {
      legend: true,
      domain: ["gat", "vgae", "dqn", "fusion"],
      range: ["#3fb950", "#58a6ff", "#d29922", "#bc8cff"],
    },
    marks: [
      Plot.dot(data, {
        x: "param_count_M",
        y: "f1",
        fill: "model",
        stroke: "model",
        r: 8,
        tip: true,
        title: d => `${d.label}\nF1: ${d.f1.toFixed(4)}\nParams: ${d.param_count_M}M`,
      }),
      Plot.line(pareto, {
        x: "param_count_M",
        y: "f1",
        stroke: "#f85149",
        strokeWidth: 2,
        strokeDasharray: "6,3",
      }),
      Plot.text(data, {
        x: "param_count_M",
        y: "f1",
        text: "label",
        dy: -14,
        fontSize: 10,
      }),
    ],
  });
}
```

## Row {height=50%}

```{ojs}
//| title: "F1 vs AUC by Model"
vg.plot(
  vg.dot(
    vg.from("metrics"),
    {
      x: "auc",
      y: "f1",
      fill: "model",
      stroke: "model",
      r: 6,
      opacity: 0.7
    }
  ),
  vg.width(500),
  vg.height(320),
  vg.colorLegend(true),
  vg.colorDomain(["gat", "vgae", "fusion"]),
  vg.colorRange(["#3fb950", "#58a6ff", "#bc8cff"]),
  vg.xLabel("AUC"),
  vg.xDomain([0.8, 1.01]),
  vg.yLabel("F1 Score"),
  vg.yDomain([0.5, 1.01])
)
```

```{ojs}
//| title: "Runs by Dataset"
{
  const result = await vg.coordinator().query(
    vg.sql`
      SELECT split_part(run_id, '/', 1) AS dataset,
             model_type,
             COUNT(*) AS n
      FROM runs
      GROUP BY 1, 2
      ORDER BY 1, 2
    `
  );
  const data = Array.from(result);
  return Plot.plot({
    width: 500,
    height: 320,
    marginLeft: 60,
    x: { label: "Number of Runs" },
    y: { label: null },
    color: { legend: true, domain: ["vgae", "gat", "dqn", "eval"], range: ["#58a6ff", "#3fb950", "#d29922", "#bc8cff"] },
    marks: [
      Plot.barX(data, Plot.stackX({
        y: "dataset",
        x: "n",
        fill: "model_type",
        sort: { y: "-x" }
      })),
      Plot.ruleX([0])
    ]
  });
}
```

# Training

## Row {height=35%}

```{ojs}
//| title: "Training Duration by Run"
{
  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        run_id,
        split_part(run_id, '/', 1) AS dataset,
        model_type,
        scale,
        stage,
        CASE
          WHEN duration_seconds IS NOT NULL AND duration_seconds > 0
          THEN duration_seconds / 60.0
          WHEN started_at IS NOT NULL AND completed_at IS NOT NULL
          THEN EXTRACT(EPOCH FROM (CAST(completed_at AS TIMESTAMP) - CAST(started_at AS TIMESTAMP))) / 60.0
          ELSE NULL
        END AS duration_min
      FROM runs
      WHERE stage NOT IN ('evaluation')
    `
  );
  const data = Array.from(result).filter(d => d.duration_min != null && d.duration_min > 0);

  return Plot.plot({
    width: 900,
    height: Math.max(200, data.length * 18),
    marginLeft: 220,
    x: { label: "Duration (minutes)" },
    y: { label: null },
    color: {
      legend: true,
      domain: ["vgae", "gat", "dqn"],
      range: ["#58a6ff", "#3fb950", "#d29922"],
    },
    marks: [
      Plot.barX(data, {
        y: "run_id",
        x: "duration_min",
        fill: "model_type",
        sort: { y: "-x" },
        tip: true,
        title: d => `${d.run_id}\n${d.duration_min.toFixed(1)} min`,
      }),
      Plot.ruleX([0]),
    ],
  });
}
```

## Row {height=35%}

```{ojs}
//| title: "Training Curve Comparison"

viewof compareRun1 = {
  const result = await vg.coordinator().query(
    vg.sql`SELECT DISTINCT run_id FROM training_curves ORDER BY run_id`
  );
  const runs = Array.from(result, d => d.run_id);
  return Inputs.select(runs, { label: "Run A", value: runs[0] });
}

viewof compareRun2 = {
  const result = await vg.coordinator().query(
    vg.sql`SELECT DISTINCT run_id FROM training_curves ORDER BY run_id`
  );
  const runs = Array.from(result, d => d.run_id);
  return Inputs.select(runs, { label: "Run B", value: runs.length > 1 ? runs[1] : runs[0] });
}

{
  const r1 = await vg.coordinator().query(
    vg.sql`SELECT epoch, metric_name, value, run_id FROM training_curves WHERE run_id = '${compareRun1}'`
  );
  const r2 = await vg.coordinator().query(
    vg.sql`SELECT epoch, metric_name, value, run_id FROM training_curves WHERE run_id = '${compareRun2}'`
  );
  const data = [...Array.from(r1), ...Array.from(r2)];

  return Plot.plot({
    width: 900,
    height: 320,
    color: { legend: true },
    symbol: { legend: true },
    x: { label: "Epoch" },
    y: { label: "Value" },
    marks: [
      Plot.line(data, {
        x: "epoch",
        y: "value",
        stroke: "metric_name",
        strokeDasharray: d => d.run_id === compareRun1 ? null : "4,3",
        tip: true,
      }),
    ],
  });
}
```

## Row {height=30%}

```{ojs}
//| title: "Training Carpet (Metric × Epoch Heatmap)"
{
  const sel = vg.Selection.single();
  return vg.vconcat(
    vg.menu({ from: "training_curves", column: "run_id", label: "Run", as: sel }),
    vg.plot(
      vg.cell(
        vg.from("training_curves", { filterBy: sel }),
        { x: "epoch", y: "metric_name", fill: "value", inset: 0.5 }
      ),
      vg.width(900),
      vg.height(200),
      vg.colorScheme("viridis"),
      vg.colorLegend(true),
      vg.colorLabel("Value"),
      vg.xLabel("Epoch"),
      vg.yLabel(null)
    )
  );
}
```

# GAT & DQN

## Row {height=50%}

```{ojs}
//| title: "GAT Attention Weights by Layer"
{
  const sel = vg.Selection.single();
  return vg.vconcat(
    vg.menu({ from: "attention_weights", column: "run_id", label: "Run", as: sel }),
    vg.plot(
      vg.cell(
        vg.from("attention_weights", { filterBy: sel }),
        {
          x: vg.sql`'Head ' || head`,
          y: vg.sql`'Layer ' || layer`,
          fill: "mean_alpha",
          inset: 0.5
        }
      ),
      vg.width(500),
      vg.height(280),
      vg.colorScheme("blues"),
      vg.colorLegend(true),
      vg.colorLabel("Mean Attention"),
      vg.xLabel("Attention Head"),
      vg.yLabel("GAT Layer")
    )
  );
}
```

```{ojs}
//| title: "DQN Fusion Policy (Alpha Distribution)"
{
  const sel = vg.Selection.single();
  return vg.vconcat(
    vg.menu({ from: "dqn_policy", column: "run_id", label: "Run", as: sel }),
    vg.plot(
      vg.rectY(
        vg.from("dqn_policy", { filterBy: sel }),
        {x: vg.bin("alpha"), y: vg.count(), fill: "steelblue", insetLeft: 0.5, insetRight: 0.5}
      ),
      vg.width(500),
      vg.height(280),
      vg.colorScheme("oranges"),
      vg.xLabel("Alpha (GAT weight in fusion)"),
      vg.yLabel("Count")
    )
  );
}
```

## Row {height=50%}

```{ojs}
//| title: "Training Curves (single run)"
{
  const sel = vg.Selection.single();
  return vg.vconcat(
    vg.menu({ from: "training_curves", column: "run_id", label: "Run", as: sel }),
    vg.plot(
      vg.lineY(
        vg.from("training_curves", { filterBy: sel }),
        { x: "epoch", y: "value", stroke: "metric_name" }
      ),
      vg.width(680),
      vg.height(350),
      vg.colorLegend(true),
      vg.xLabel("Epoch"),
      vg.yLabel("Value")
    )
  );
}
```

```{ojs}
//| title: "VGAE Reconstruction Errors"
{
  const sel = vg.Selection.single();
  return vg.vconcat(
    vg.menu({ from: "recon_errors", column: "run_id", label: "Run", as: sel }),
    vg.plot(
      vg.rectY(
        vg.from("recon_errors", { filterBy: sel }),
        {
          x: vg.bin("error"),
          y: vg.count(),
          fill: vg.sql`CASE WHEN label = 0 THEN 'normal' ELSE 'attack' END`,
          insetLeft: 0.5,
          insetRight: 0.5
        }
      ),
      vg.width(680),
      vg.height(350),
      vg.colorLegend(true),
      vg.colorDomain(["normal", "attack"]),
      vg.colorRange(["#3fb950", "#f85149"]),
      vg.xLabel("Reconstruction Error"),
      vg.yLabel("Count")
    )
  );
}
```

# Knowledge Distillation

## Row {height=50%}

```{ojs}
//| title: "KD Transfer: Teacher vs Student"

viewof selectedKdMetric = Inputs.select(
  ["f1", "accuracy", "auc"],
  { label: "Metric", value: "f1" }
)

{
  const data = kd_transfer_json.data.filter(d => d.metric_name === selectedKdMetric);
  const metricLabel = selectedKdMetric.toUpperCase();
  return Plot.plot({
    width: 600,
    height: 320,
    x: { label: `Teacher ${metricLabel} (Large)`, domain: [0.5, 1.01] },
    y: { label: `Student ${metricLabel} (Small + KD)`, domain: [0.5, 1.01] },
    color: { legend: true },
    marks: [
      Plot.line([[0.5, 0.5], [1, 1]], { stroke: "#8b949e", strokeDasharray: "4,4", strokeWidth: 1 }),
      Plot.dot(data, {
        x: "teacher_value",
        y: "student_value",
        fill: "dataset",
        stroke: "dataset",
        r: 7,
        tip: true,
        title: d => `${d.dataset} / ${d.model_type}\nTeacher: ${d.teacher_value.toFixed(4)}\nStudent: ${d.student_value.toFixed(4)}`
      }),
      Plot.text(data, {
        x: "teacher_value",
        y: "student_value",
        text: d => d.model_type.slice(0, 3),
        dy: -12,
        fontSize: 10
      })
    ]
  });
}
```

```{ojs}
//| title: "CKA Similarity (Teacher-Student Layer Alignment)"
{
  const sel = vg.Selection.single();
  return vg.vconcat(
    vg.menu({ from: "cka_similarity", column: "run_id", label: "Run", as: sel }),
    vg.plot(
      vg.cell(
        vg.from("cka_similarity", { filterBy: sel }),
        {
          x: "student_layer",
          y: "teacher_layer",
          fill: "similarity",
          inset: 0.5
        }
      ),
      vg.width(400),
      vg.height(300),
      vg.colorScheme("viridis"),
      vg.colorLegend(true),
      vg.colorLabel("CKA Similarity"),
      vg.xLabel("Student Layer"),
      vg.yLabel("Teacher Layer")
    )
  );
}
```

## Row {height=50%}

```{ojs}
//| output: false
await vg.coordinator().exec(
  vg.sql`CREATE OR REPLACE TEMP VIEW embeddings_vgae AS SELECT * FROM embeddings WHERE model = 'vgae'`
);
await vg.coordinator().exec(
  vg.sql`CREATE OR REPLACE TEMP VIEW embeddings_gat AS SELECT * FROM embeddings WHERE model = 'gat'`
);
embRunSel = vg.Selection.single()
```

```{ojs}
//| title: "UMAP Embeddings (VGAE)"
vg.vconcat(
  vg.menu({ from: "embeddings_vgae", column: "run_id", label: "Run", as: embRunSel }),
  vg.plot(
    vg.dot(
      vg.from("embeddings_vgae", { filterBy: embRunSel }),
      {
        x: "x",
        y: "y",
        fill: vg.sql`CASE WHEN label = 0 THEN 'normal' ELSE 'attack' END`,
        r: 2,
        opacity: 0.5
      }
    ),
    vg.width(600),
    vg.height(350),
    vg.colorLegend(true),
    vg.colorDomain(["normal", "attack"]),
    vg.colorRange(["#3fb950", "#f85149"]),
    vg.xLabel("UMAP 1"),
    vg.xAxis(null),
    vg.yLabel("UMAP 2"),
    vg.yAxis(null)
  )
)
```

```{ojs}
//| title: "UMAP Embeddings (GAT)"
vg.plot(
  vg.dot(
    vg.from("embeddings_gat", { filterBy: embRunSel }),
    {
      x: "x",
      y: "y",
      fill: vg.sql`CASE WHEN label = 0 THEN 'normal' ELSE 'attack' END`,
      r: 2,
      opacity: 0.5
    }
  ),
  vg.width(600),
  vg.height(350),
  vg.colorLegend(true),
  vg.colorDomain(["normal", "attack"]),
  vg.colorRange(["#3fb950", "#f85149"]),
  vg.xLabel("UMAP 1"),
  vg.xAxis(null),
  vg.yLabel("UMAP 2"),
  vg.yAxis(null)
)
```

# Graph Structure

## Row

```{ojs}
//| title: "CAN Bus Graph Structure (Force-Directed)"

import { renderForceGraph } from "./_ojs/force-graph.js"

viewof graphDataset = {
  const datasets = [...new Set(graph_samples_json.data.map(d => d.dataset))].sort();
  return Inputs.select(datasets, { label: "Dataset", value: datasets[0] });
}

viewof graphLabel = Inputs.select(
  [null, 0, 1],
  { label: "Class", value: null, format: d => d === null ? "All" : d === 0 ? "Normal" : "Attack" }
)

viewof graphColorBy = Inputs.select(
  ["can_id", "degree"],
  { label: "Color by", value: "can_id" }
)

{
  const d3 = await import("https://cdn.jsdelivr.net/npm/d3@7/+esm");
  const container = document.createElement("div");
  container.style.position = "relative";
  container.style.width = "100%";

  // Style the tooltip
  const style = document.createElement("style");
  style.textContent = `
    .tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(13, 17, 23, 0.95);
      color: #e6edf3;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.15s;
      z-index: 10;
    }
  `;
  container.appendChild(style);

  renderForceGraph(d3, container, graph_samples_json.data, {
    dataset: graphDataset,
    label: graphLabel,
    colorBy: graphColorBy,
    width: 900,
    height: 500,
  });

  return container;
}
```

# Datasets

## Row

```{ojs}
//| title: "Dataset Catalog"
{
  const data = datasets_json.data;
  return Inputs.table(data, {
    columns: ["name", "domain", "protocol", "source", "description"],
    header: {
      name: "Dataset",
      domain: "Domain",
      protocol: "Protocol",
      source: "Source",
      description: "Description"
    },
    width: { name: 100, domain: 100, protocol: 80, source: 120, description: 300 }
  });
}
```

# Staging

## Row {height=40%}

```{ojs}
//| title: "Run Timeline"
{
  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        run_id,
        model_type,
        stage,
        started_at,
        completed_at
      FROM runs
      WHERE started_at IS NOT NULL AND completed_at IS NOT NULL
      ORDER BY started_at
    `
  );
  const data = Array.from(result).filter(d => d.started_at && d.completed_at);

  if (data.length === 0) {
    return html`<p style="color: #8b949e; text-align: center; padding: 2rem;">No runs with timing data available.</p>`;
  }

  return Plot.plot({
    width: 900,
    height: Math.max(200, data.length * 16),
    marginLeft: 220,
    x: { label: "Time", type: "utc" },
    y: { label: null },
    color: {
      legend: true,
      domain: ["vgae", "gat", "dqn", "eval"],
      range: ["#58a6ff", "#3fb950", "#d29922", "#bc8cff"],
    },
    marks: [
      Plot.barX(data, {
        y: "run_id",
        x1: "started_at",
        x2: "completed_at",
        fill: "model_type",
        sort: { y: "x1" },
        tip: true,
        title: d => `${d.run_id}\n${d.stage}\n${d.started_at} → ${d.completed_at}`,
      }),
    ],
  });
}
```

## Row {height=30%}

```{ojs}
//| title: "Model Predictions Summary"

viewof predRun = {
  const result = await vg.coordinator().query(
    vg.sql`SELECT DISTINCT run_id FROM metrics ORDER BY run_id`
  );
  const runs = Array.from(result, d => d.run_id);
  return Inputs.select(runs, { label: "Run", value: runs[0] });
}

{
  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        model,
        f1, accuracy, precision, recall, auc, mcc, n_samples
      FROM metrics
      WHERE run_id = '${predRun}'
    `
  );
  const data = Array.from(result);

  if (data.length === 0) {
    return html`<p style="color: #8b949e; text-align: center; padding: 1rem;">No metrics for this run.</p>`;
  }

  return Inputs.table(data, {
    columns: ["model", "f1", "accuracy", "precision", "recall", "auc", "mcc", "n_samples"],
    format: {
      f1: d => d?.toFixed(4),
      accuracy: d => d?.toFixed(4),
      precision: d => d?.toFixed(4),
      recall: d => d?.toFixed(4),
      auc: d => d?.toFixed(4),
      mcc: d => d?.toFixed(4),
    },
    header: {
      model: "Model", f1: "F1", accuracy: "Accuracy",
      precision: "Precision", recall: "Recall", auc: "AUC",
      mcc: "MCC", n_samples: "Samples",
    },
  });
}
```

## Row {height=30%}

```{ojs}
//| title: "Confusion Matrix Proxy (FPR vs FNR)"

{
  const result = await vg.coordinator().query(
    vg.sql`
      SELECT
        split_part(run_id, '/', 1) AS dataset,
        model,
        fpr,
        fnr
      FROM metrics
      WHERE fpr IS NOT NULL AND fnr IS NOT NULL
    `
  );
  const data = Array.from(result);

  return Plot.plot({
    width: 600,
    height: 350,
    x: { label: "False Positive Rate (FPR)", domain: [0, 0.5] },
    y: { label: "False Negative Rate (FNR)", domain: [0, 0.5] },
    color: {
      legend: true,
      domain: ["gat", "vgae", "fusion"],
      range: ["#3fb950", "#58a6ff", "#bc8cff"],
    },
    marks: [
      Plot.dot(data, {
        x: "fpr",
        y: "fnr",
        fill: "model",
        stroke: "model",
        r: 7,
        tip: true,
        title: d => `${d.dataset} / ${d.model}\nFPR: ${d.fpr.toFixed(4)}\nFNR: ${d.fnr.toFixed(4)}`,
      }),
      // Perfect classifier marker
      Plot.dot([{ x: 0, y: 0 }], {
        x: "x",
        y: "y",
        r: 10,
        stroke: "#3fb950",
        strokeWidth: 2,
        fill: "none",
      }),
      Plot.text([{ x: 0, y: 0 }], {
        x: "x",
        y: "y",
        text: ["ideal"],
        dy: 16,
        fontSize: 10,
        fill: "#8b949e",
      }),
    ],
  });
}
```
