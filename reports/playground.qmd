---
title: "Visualization Playground"
format:
  html:
    theme:
      - cosmo
      - custom.scss
    toc: false
    page-layout: full
---

A scratch pad for testing Mosaic/vgplot visualizations with the full DuckDB-WASM environment.
Shape data in `notebooks/playground.ipynb` first, then test production rendering here.

## Setup

```{ojs}
//| output: false

import { vg, loadParquetTable, listTables, describeTable } from "./_ojs/mosaic-setup.js"

// Load all Parquet tables (same as dashboard)
async function loadTable(name, attachment) {
  const url = await attachment.url();
  await vg.coordinator().exec(vg.loadParquet(name, url));
}

await loadTable("metrics", FileAttachment("data/metrics.parquet"));
await loadTable("runs", FileAttachment("data/runs.parquet"));
await loadTable("training_curves", FileAttachment("data/training_curves.parquet"));
await loadTable("recon_errors", FileAttachment("data/recon_errors.parquet"));
await loadTable("attention_weights", FileAttachment("data/attention_weights.parquet"));
await loadTable("dqn_policy", FileAttachment("data/dqn_policy.parquet"));
await loadTable("cka_similarity", FileAttachment("data/cka_similarity.parquet"));
await loadTable("embeddings", FileAttachment("data/embeddings.parquet"));
await loadTable("datasets", FileAttachment("data/datasets.parquet"));

tableList = await listTables()
tableNames = tableList.map(t => t.name)
```

Data loaded: **${tableNames.length} tables** — ${tableNames.join(", ")}

---

## Table Browser

```{ojs}
viewof selectedTable = Inputs.select(tableNames, {label: "Table", value: tableNames[0]})
```

```{ojs}
schema = await describeTable(selectedTable)
Inputs.table(schema, {columns: ["column_name", "column_type", "null"], width: {column_name: 200, column_type: 120, null: 60}})
```

```{ojs}
preview = {
  const result = await vg.coordinator().query(
    `SELECT * FROM ${selectedTable} LIMIT 50`
  );
  return Array.from(result);
}
Inputs.table(preview, {maxWidth: 900})
```

---

## SQL Console

```{ojs}
viewof sqlQuery = Inputs.textarea({
  label: "SQL",
  rows: 4,
  value: "SELECT split_part(run_id, '/', 1) AS dataset, model, f1, accuracy\nFROM metrics\nORDER BY f1 DESC",
  width: "100%",
  submit: "Run"
})
```

```{ojs}
sqlResult = {
  try {
    const result = await vg.coordinator().query(sqlQuery);
    return {data: Array.from(result), error: null};
  } catch (e) {
    return {data: null, error: e.message};
  }
}
```

```{ojs}
sqlResult.error
  ? html`<pre style="color: #dc2626; padding: 8px; background: #fef2f2; border-radius: 4px;">${sqlResult.error}</pre>`
  : Inputs.table(sqlResult.data, {maxWidth: 900})
```

---

## Quick Chart Builder

```{ojs}
viewof chartTable = Inputs.select(tableNames, {label: "Table", value: "metrics"})
```

```{ojs}
chartCols = {
  const s = await describeTable(chartTable);
  return s.map(c => c.column_name);
}
```

```{ojs}
viewof chartX = Inputs.select(chartCols, {label: "X axis", value: chartCols[0]})
viewof chartY = Inputs.select(chartCols, {label: "Y axis", value: chartCols.length > 1 ? chartCols[1] : chartCols[0]})
viewof chartColor = Inputs.select(["none", ...chartCols], {label: "Color", value: "none"})
viewof chartMark = Inputs.select(["dot", "barY", "barX", "lineY", "rectY", "cell"], {label: "Mark type", value: "dot"})
```

```{ojs}
{
  const markFn = vg[chartMark];
  const encoding = {x: chartX, y: chartY};
  if (chartColor !== "none") encoding.fill = chartColor;
  if (chartMark === "dot") encoding.r = 5;

  return vg.plot(
    markFn(vg.from(chartTable), encoding),
    vg.width(680),
    vg.height(400),
    chartColor !== "none" ? vg.colorLegend(true) : []
  );
}
```

---

## Scratch Cells

Use these cells for ad-hoc Mosaic/vgplot experiments. Copy working code to dashboard.qmd or paper chapters.

### Scratch 1: Custom Mosaic chart

```{ojs}
// Example: F1 by dataset and model (dot plot)
// Uncomment and modify:
//
// vg.plot(
//   vg.dot(
//     vg.from("metrics"),
//     {x: "model", y: "f1", fill: "model", r: 8}
//   ),
//   vg.width(680),
//   vg.height(400),
//   vg.colorLegend(true)
// )
html`<em>Uncomment the code above to render a chart.</em>`
```

### Scratch 2: SQL aggregation → table

```{ojs}
// Example: aggregate training curves
// Uncomment and modify:
//
// scratch2 = {
//   const result = await vg.coordinator().query(
//     vg.sql`SELECT run_id, COUNT(*) AS n_epochs FROM training_curves GROUP BY run_id`
//   );
//   return Array.from(result);
// }
// Inputs.table(scratch2)
html`<em>Uncomment the code above to run a query.</em>`
```

### Scratch 3: Observable Plot (non-Mosaic)

```{ojs}
// For quick static charts without Mosaic cross-filtering:
// const Plot = await import("https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm");
// Plot.plot({
//   marks: [Plot.dot(sqlResult.data, {x: "col_x", y: "col_y"})],
//   width: 680
// })
html`<em>Uncomment the code above to render an Observable Plot chart.</em>`
```

---

## File Upload

Upload ad-hoc Parquet files to explore data not yet in the export pipeline.

```{ojs}
viewof uploadedFile = Inputs.file({label: "Upload Parquet", accept: ".parquet"})
```

```{ojs}
uploadStatus = {
  if (!uploadedFile) return "No file uploaded.";
  const tableName = uploadedFile.name.replace(/\.parquet$/, "").replace(/[^a-zA-Z0-9_]/g, "_");
  const url = URL.createObjectURL(uploadedFile);
  try {
    await vg.coordinator().exec(vg.loadParquet(tableName, url));
    return `Loaded as table "${tableName}". Refresh the Table Browser dropdown to see it.`;
  } catch (e) {
    return `Error: ${e.message}`;
  }
}
```

${uploadStatus}
